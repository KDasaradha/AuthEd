import type { AuthType } from './types';
import { 
    ApiKeyDiagram, 
    BasicAuthDiagram, 
    GenericAuthDiagram, 
    OAuth2Diagram 
} from '@/components/auth/AuthTypeDiagrams';
import { PlaceholderSetup } from '@/components/auth/PlaceholderSetup';

export const authTypes: AuthType[] = [
  {
    slug: "basic-authentication",
    name: "Basic Authentication",
    description: "A simple method using a username and password encoded in Base64.",
    useCase: "Internal APIs, simple services where transport is secured by TLS.",
    security: "Low",
    complexity: "Low",
    protocols: "HTTP",
    phishingResistance: 'Low',
    ux: 'Medium Friction',
    credentialType: 'Password',
    standardization: 'IETF RFC 7617',
    technicalExplanation: "HTTP Basic Authentication is a simple challenge-response mechanism where a user agent provides a username and password. These credentials are combined into a 'username:password' string, encoded using Base64, and sent in the `Authorization` header of every HTTP request. Example: `Authorization: Basic dXNlcjpwYXNz`. Critically, Base64 is an encoding, not encryption, so credentials are sent in a reversible format. Without HTTPS (TLS) to encrypt the entire request, this method is highly insecure and vulnerable to sniffing. It is stateless, requiring credentials to be sent with each request.",
    setupInstructions: PlaceholderSetup,
    diagram: BasicAuthDiagram,
    pros: ["Extremely simple to implement", "Universally supported"],
    cons: ["Insecure without TLS", "Sends credentials with every request"],
    ssoCapability: 'Not Suited',
    developerExperience: 'Easy',
  },
  {
    slug: "token-based-authentication",
    name: "Token-Based (JWT)",
    description: "Uses a signed token (JWT) to verify user identity and claims.",
    useCase: "SPAs, Mobile Apps, APIs, server-to-server communication.",
    security: "Medium",
    complexity: "Medium",
    protocols: "HTTP, WebSocket",
    phishingResistance: 'Low',
    ux: 'Low Friction',
    credentialType: 'Bearer Token',
    standardization: 'IETF RFC 7519',
    technicalExplanation: "After a user logs in with credentials, the server creates a JSON Web Token (JWT) and sends it to the client. A JWT is a self-contained, stateless token with three parts: a header, a payload (containing user data or 'claims' like user ID and roles), and a cryptographic signature. The signature, created with a secret key known only to the server, ensures the token's integrity. The client stores this token (e.g., in localStorage or a secure cookie) and sends it with every protected request in the `Authorization: Bearer <token>` header. The server can then validate the token without needing to look up session data.",
    setupInstructions: PlaceholderSetup,
    diagram: GenericAuthDiagram,
    pros: ["Stateless and scalable", "Good for SPAs and mobile apps", "Decouples client and server"],
    cons: ["Token revocation is complex", "Tokens can grow large", "Secret management is critical"],
    ssoCapability: 'Possible',
    developerExperience: 'Moderate',
  },
  {
    slug: "oauth2-authentication",
    name: "OAuth2 Authentication",
    description: "A delegation protocol for third-party access to user resources.",
    useCase: "Third-party services (e.g., 'Log in with Google'), granting limited API access.",
    security: "High",
    complexity: "High",
    protocols: "HTTP",
    phishingResistance: 'Medium',
    ux: 'Low Friction',
    credentialType: 'Access Token',
    standardization: 'IETF RFC 6749',
    technicalExplanation: "OAuth2 is an authorization framework, not an authentication protocol. It enables an application (the Client) to obtain limited, delegated access to a user's resources on another service (the Resource Server), without exposing their credentials. It defines roles (Resource Owner, Client, Authorization Server, Resource Server) and various 'grant types' (flows) like Authorization Code for web apps, which is considered the most secure for that context. The outcome is an Access Token, which is a key that grants specific, scoped permissions.",
    setupInstructions: PlaceholderSetup,
    diagram: OAuth2Diagram,
    pros: ["Delegated access model", "Granular scopes and permissions", "Wide industry adoption"],
    cons: ["Complex specification with multiple flows", "Not an authentication protocol by itself"],
    ssoCapability: 'Possible',
    developerExperience: 'Complex',
  },
  {
    slug: "session-based-authentication",
    name: "Session-Based Authentication",
    description: "Server stores session data and provides a session ID to the client.",
    useCase: "Traditional monolithic web applications, server-rendered pages.",
    security: "Medium",
    complexity: "Low",
    protocols: "HTTP (Cookies)",
    phishingResistance: 'Low',
    ux: 'Low Friction',
    credentialType: 'Session ID (Cookie)',
    standardization: 'De facto',
    technicalExplanation: "In this stateful model, the server creates and maintains a session for a user upon successful login. It stores session information (like user ID) on the server-side (in memory, a database, or a cache like Redis) and sends a unique Session ID to the client. This ID is typically sent in a secure, `HttpOnly` cookie. The browser automatically sends this cookie with every subsequent request, allowing the server to look up the session data, identify the user, and maintain their authenticated state across multiple page views.",
    setupInstructions: PlaceholderSetup,
    diagram: GenericAuthDiagram,
    pros: ["Simple to understand and implement", "Mature and well-understood", "Easy to revoke sessions"],
    cons: ["Requires server-side storage (stateful)", "Doesn't scale well horizontally", "Vulnerable to CSRF without protection"],
    ssoCapability: 'Not Suited',
    developerExperience: 'Easy',
  },
  {
    slug: "api-key-authentication",
    name: "API Key Authentication",
    description: "A unique key is assigned to each application to access the API.",
    useCase: "Public APIs, usage tracking, server-to-server identification.",
    security: "Low",
    complexity: "Low",
    protocols: "HTTP",
    phishingResistance: 'Low',
    ux: 'N/A',
    credentialType: 'Static Key',
    standardization: 'De facto',
    technicalExplanation: "API keys are used to identify the consuming application or project making a request, not a specific end-user. It's a simple way to control access, track usage for billing, and apply rate limiting. The key is a long, unique string that the client sends with each request, typically in a custom HTTP header like `X-API-Key`, a query parameter, or the request body. Because the key is static and often long-lived, it should be treated like a secret and protected accordingly. It does not provide user-level authentication.",
    setupInstructions: PlaceholderSetup,
    diagram: ApiKeyDiagram,
    pros: ["Simple to generate and use", "Good for identifying applications"],
    cons: ["Not for user authentication", "Vulnerable if exposed", "No standard for key placement"],
    ssoCapability: 'Not Suited',
    developerExperience: 'Easy',
  },
  {
    slug: "digest-authentication",
    name: "Digest Authentication",
    description: "A challenge-response method that hashes credentials before sending.",
    useCase: "Situations requiring more security than Basic Auth without implementing TLS.",
    security: "Low",
    complexity: "Medium",
    protocols: "HTTP",
    phishingResistance: 'Low',
    ux: 'Medium Friction',
    credentialType: 'Password (hashed)',
    standardization: 'IETF RFC 7616',
    technicalExplanation: "As a challenge-response protocol, Digest Auth improves on Basic Auth by never sending the password in cleartext. The server sends a 'nonce' (a random value). The client creates an MD5 hash of the username, password, nonce, URI, and HTTP method. This hash is sent to the server, which performs the same calculation to verify. While better than Basic, it is still vulnerable to man-in-the-middle attacks (without TLS) and uses the outdated MD5 algorithm. It is largely considered obsolete in favor of modern protocols.",
    setupInstructions: PlaceholderSetup,
    diagram: GenericAuthDiagram,
    pros: ["Doesn't send password in cleartext"],
    cons: ["Considered obsolete", "Uses weak MD5 hashing", "Vulnerable to MITM without TLS"],
    ssoCapability: 'Not Suited',
    developerExperience: 'Moderate',
  },
  {
    slug: "certificate-based-authentication",
    name: "Certificate-Based Auth",
    description: "Uses client-side digital certificates to verify identity.",
    useCase: "High-security corporate environments, B2B, and IoT devices.",
    security: "High",
    complexity: "High",
    protocols: "TLS/SSL",
    phishingResistance: 'High',
    ux: 'Low Friction',
    credentialType: 'Private Key',
    standardization: 'X.509 (IETF)',
    technicalExplanation: "This method, also known as Mutual TLS (mTLS), uses X.509 digital certificates for strong authentication. The client presents its own certificate to the server during the TLS handshake. The server verifies that the certificate was issued by a trusted Certificate Authority (CA) and has not been revoked. This provides strong, passwordless authentication for a user or device, as possession of the certificate and its corresponding private key proves identity. It is a cornerstone of Zero Trust architectures for service-to-service communication.",
    setupInstructions: PlaceholderSetup,
    diagram: GenericAuthDiagram,
    pros: ["Very high security", "Phishing resistant", "Passwordless"],
    cons: ["Complex certificate management (issuance, revocation)", "High implementation overhead"],
    ssoCapability: 'Possible',
    developerExperience: 'Complex',
  },
  {
    slug: "openid-connect",
    name: "OpenID Connect (OIDC)",
    description: "An identity layer on top of OAuth2 for user authentication.",
    useCase: "SSO, federated identity, modern consumer and enterprise applications.",
    security: "High",
    complexity: "High",
    protocols: "HTTP, OAuth2",
    phishingResistance: 'Medium',
    ux: 'Low Friction',
    credentialType: 'ID Token (JWT)',
    standardization: 'OpenID Foundation',
    technicalExplanation: "OIDC is a thin identity layer built on top of OAuth 2.0. While OAuth 2.0 provides authorization ('what a user can do'), OIDC provides authentication ('who a user is'). It introduces the `ID Token`, a specially formatted JSON Web Token (JWT) that contains user profile information (claims like name, email, etc.). It standardizes how clients can verify the identity of the end-user based on the authentication performed by an Authorization Server, as well as to obtain basic profile information about the end-user in an interoperable and REST-like manner.",
    setupInstructions: PlaceholderSetup,
    diagram: OAuth2Diagram,
    pros: ["Standardized identity layer", "Enables SSO", "Built on modern standards (OAuth2, JWT)"],
    cons: ["Inherits complexity of OAuth2", "Requires understanding of various flows"],
    ssoCapability: 'Native',
    developerExperience: 'Complex',
  },
  {
    slug: "saml",
    name: "SAML",
    description: "An XML-based standard for exchanging authentication and authorization data.",
    useCase: "Enterprise SSO, federated identity between different organizations.",
    security: "High",
    complexity: "High",
    protocols: "HTTP, SOAP",
    phishingResistance: 'Medium',
    ux: 'Low Friction',
    credentialType: 'SAML Assertion (XML)',
    standardization: 'OASIS',
    technicalExplanation: "Security Assertion Markup Language (SAML) is an XML-based open standard for exchanging authentication and authorization data between an Identity Provider (IdP) and a Service Provider (SP). It enables web-based Single Sign-On (SSO) by allowing the IdP, which holds the user's identity, to send a signed XML document, called a SAML Assertion, to the SP. The SP trusts this assertion to authenticate and authorize the user without needing direct access to the user's credentials.",
    setupInstructions: PlaceholderSetup,
    diagram: OAuth2Diagram,
    pros: ["Mature standard for enterprise SSO", "Robust and feature-rich"],
    cons: ["XML-based (verbose)", "Considered legacy compared to OIDC", "Complex to debug"],
    ssoCapability: 'Native',
    developerExperience: 'Complex',
  },
  {
    slug: "multi-factor-authentication",
    name: "Multi-Factor (MFA)",
    description: "Requires two or more verification factors to gain access.",
    useCase: "Securing sensitive accounts, regulatory compliance (e.g., PCI DSS).",
    security: "High",
    complexity: "Medium",
    protocols: "Varies",
    phishingResistance: 'High',
    ux: 'High Friction',
    credentialType: 'Multiple Factors',
    standardization: 'Varies',
    technicalExplanation: "MFA provides layered security by requiring users to present at least two pieces of evidence (factors) to an authentication mechanism. These factors fall into three categories: Knowledge (something you know, like a password or PIN), Possession (something you have, like a phone app, SMS code, or hardware token), and Inherence (something you are, like a fingerprint or face scan). Requiring multiple factors makes it significantly harder for an unauthorized person to gain access.",
    setupInstructions: PlaceholderSetup,
    diagram: GenericAuthDiagram,
    pros: ["Dramatically increases security", "Protects against credential stuffing"],
    cons: ["Adds friction to user experience", "Can be complex to implement correctly"],
    ssoCapability: 'Possible',
    developerExperience: 'Moderate',
  },
  {
    slug: "biometric-authentication",
    name: "Biometric Authentication",
    description: "Uses unique biological characteristics (fingerprint, face).",
    useCase: "Mobile devices, high-security access, passwordless login.",
    security: "High",
    complexity: "High",
    protocols: "Varies (FIDO/WebAuthn)",
    phishingResistance: 'High',
    ux: 'Low Friction',
    credentialType: 'Biometric',
    standardization: 'FIDO Alliance',
    technicalExplanation: "Biometric authentication verifies identity using unique physical traits. In modern secure systems (like FIDO2/WebAuthn), the biometric data (e.g., fingerprint scan) never leaves the user's device. Instead, it is used locally to unlock a cryptographic private key stored in a secure element on the device. This private key then signs a challenge from the server, proving both possession of the device and the user's presence in a highly secure, private, and phishing-resistant manner.",
    setupInstructions: PlaceholderSetup,
    diagram: GenericAuthDiagram,
    pros: ["Highly convenient for users", "Strong phishing resistance (with FIDO)", "Passwordless"],
    cons: ["Biometric data cannot be changed if compromised", "High implementation complexity"],
    ssoCapability: 'Possible',
    developerExperience: 'Complex',
  },
  {
    slug: "kerberos-authentication",
    name: "Kerberos Authentication",
    description: "A network authentication protocol using tickets to prove identity.",
    useCase: "Windows Active Directory, large corporate networks, Unix systems.",
    security: "High",
    complexity: "High",
    protocols: "TCP/UDP",
    phishingResistance: 'High',
    ux: 'Low Friction',
    credentialType: 'Kerberos Ticket',
    standardization: 'IETF RFC 4120',
    technicalExplanation: "Kerberos is a ticket-based protocol that uses a trusted third party, a Key Distribution Center (KDC), to provide strong, mutual authentication. A client authenticates once to the KDC to get a Ticket-Granting Ticket (TGT). The client then uses this TGT to request service tickets for specific applications without re-entering a password. This avoids sending passwords over the network and is the default authentication protocol in Windows Active Directory.",
    setupInstructions: PlaceholderSetup,
    diagram: OAuth2Diagram,
    pros: ["Very strong security for internal networks", "Enables SSO within a domain"],
    cons: ["Complex to set up and manage", "Not designed for internet/web use", "Single point of failure (KDC)"],
    ssoCapability: 'Native',
    developerExperience: 'Complex',
  },
  {
    slug: "single-sign-on",
    name: "Single Sign-On (SSO)",
    description: "Log in once to access multiple independent software systems.",
    useCase: "Corporate environments, large platforms with multiple services (e.g., Google Suite).",
    security: "High",
    complexity: "High",
    protocols: "SAML, OIDC",
    phishingResistance: 'Medium',
    ux: 'Low Friction',
    credentialType: 'Varies (Token/Assertion)',
    standardization: 'SAML, OIDC',
    technicalExplanation: "SSO is an authentication scheme, not a specific protocol itself. It allows a user to log in once with a single set of credentials to a central Identity Provider (IdP) and gain access to multiple, separate applications without re-authenticating. This is achieved through federation protocols like SAML or OIDC. Applications (Service Providers) are configured to trust the IdP. When a user tries to access an SP, the SP redirects them to the IdP for authentication. After a successful login, the IdP sends a secure assertion back to the SP, which then grants the user access.",
    setupInstructions: PlaceholderSetup,
    diagram: OAuth2Diagram,
    pros: ["Greatly improved user experience", "Centralized access control", "Reduces password fatigue"],
    cons: ["IdP is a single point of failure", "Complex to configure trust relationships"],
    ssoCapability: 'Native',
    developerExperience: 'Complex',
  },
  {
    slug: "hmac-authentication",
    name: "HMAC Authentication",
    description: "Uses a cryptographic hash function and a secret key for message authentication.",
    useCase: "Securing webhook endpoints, server-to-server API calls.",
    security: "Medium",
    complexity: "Medium",
    protocols: "HTTP",
    phishingResistance: 'Medium',
    ux: 'N/A',
    credentialType: 'Shared Secret',
    standardization: 'IETF RFC 2104',
    technicalExplanation: "HMAC (Hash-based Message Authentication Code) verifies both the integrity and authenticity of a request. The client and server share a secret key. To make a request, the client creates a signature by hashing the request content (and often other parts like the URI and a timestamp) with an algorithm like SHA256. The server performs the same calculation on the received message and compares its result to the signature sent by the client. If they match, the server knows the request is from a trusted source and hasn't been tampered with in transit.",
    setupInstructions: PlaceholderSetup,
    diagram: GenericAuthDiagram,
    pros: ["Protects against message tampering", "Prevents replay attacks (with nonce/timestamp)"],
    cons: ["Requires secure shared secret distribution", "Can be complex to implement correctly"],
    ssoCapability: 'Not Suited',
    developerExperience: 'Moderate',
  },
  {
    slug: "ntlm-authentication",
    name: "NTLM Authentication",
    description: "A suite of Microsoft security protocols for challenge-response authentication.",
    useCase: "Legacy Windows environments, backward compatibility within intranets.",
    security: "Low",
    complexity: "High",
    protocols: "Varies",
    phishingResistance: 'Low',
    ux: 'Low Friction',
    credentialType: 'Password Hash',
    standardization: 'Proprietary (Microsoft)',
    technicalExplanation: "NTLM (New Technology LAN Manager) is a legacy challenge-response protocol common in older Windows networks. It's known to be vulnerable to relay attacks and pass-the-hash attacks, and is not recommended for modern applications or use over the internet. It has been largely superseded by Kerberos in Active Directory environments. Its continued use is typically for backward compatibility with old applications or devices that do not support Kerberos.",
    setupInstructions: PlaceholderSetup,
    diagram: GenericAuthDiagram,
    pros: ["Backward compatibility in Windows environments"],
    cons: ["Many known vulnerabilities", "Superseded by Kerberos", "Not for internet use"],
    ssoCapability: 'Possible',
    developerExperience: 'Complex',
  },
  {
    slug: "ldap-authentication",
    name: "LDAP Authentication",
    description: "Validates user credentials against an LDAP directory service.",
    useCase: "Centralized user management in corporate networks (e.g., Active Directory).",
    security: "Medium",
    complexity: "Medium",
    protocols: "LDAP",
    phishingResistance: 'Low',
    ux: 'Medium Friction',
    credentialType: 'Password',
    standardization: 'IETF RFC 4511',
    technicalExplanation: "Lightweight Directory Access Protocol (LDAP) is a protocol for accessing and maintaining distributed directory information services like Active Directory. For authentication, an application performs a 'bind' operation to the LDAP server. A simple bind with a user's Distinguished Name (DN) and password will succeed if the credentials are correct. This allows applications to centralize user management without storing passwords themselves. All communication must be encrypted via LDAPS (LDAP over SSL) or STARTTLS.",
    setupInstructions: PlaceholderSetup,
    diagram: GenericAuthDiagram,
    pros: ["Centralizes user directory", "Standard protocol for directory services"],
    cons: ["Insecure without LDAPS/TLS", "Can be complex to manage directory structure"],
    ssoCapability: 'Possible',
    developerExperience: 'Moderate',
  },
  {
    slug: "anonymous-authentication",
    name: "Anonymous Authentication",
    description: "Grants access to public resources without verifying identity.",
    useCase: "Public websites, guest access, read-only content.",
    security: "Low",
    complexity: "Low",
    protocols: "HTTP",
    phishingResistance: 'N/A',
    ux: 'Low Friction',
    credentialType: 'None',
    standardization: 'N/A',
    technicalExplanation: "This isn't a form of authentication as much as a deliberate lack of it. The server is configured to allow access to specific resources without requiring any credentials. On the backend, the user might be assigned a generic, low-privilege 'anonymous' identity to standardize authorization checks. It's essential for any public-facing content and is the default state for most websites before a user logs in.",
    setupInstructions: PlaceholderSetup,
    diagram: GenericAuthDiagram,
    pros: ["No friction for users", "Simple for public content"],
    cons: ["Provides no user identity", "Not suitable for protected resources"],
    ssoCapability: 'Not Suited',
    developerExperience: 'Easy',
  },
  {
    slug: "challenge-response-authentication",
    name: "Challenge-Response Auth",
    description: "Server sends a challenge, client responds with a computed value.",
    useCase: "Secure passwordless systems, preventing replay attacks.",
    security: "Medium",
    complexity: "Medium",
    protocols: "Varies",
    phishingResistance: 'Medium',
    ux: 'Medium Friction',
    credentialType: 'Varies (Secret)',
    standardization: 'Varies',
    technicalExplanation: "This is a family of protocols where a secret (like a password or key) is never transmitted directly over the network. The verifier sends a random, single-use value (the challenge or 'nonce'). The claimant uses a shared secret to perform a cryptographic calculation with the nonce and sends the result (the response). The verifier performs the same calculation to validate the response. This prevents replay attacks, as a new challenge is used for each authentication attempt. Examples include Digest, NTLM, and parts of the Kerberos and WebAuthn flows.",
    setupInstructions: PlaceholderSetup,
    diagram: GenericAuthDiagram,
    pros: ["Secrets are not sent over the network", "Resistant to replay attacks"],
    cons: ["Can be complex", "Strength depends on the underlying algorithm"],
    ssoCapability: 'Not Suited',
    developerExperience: 'Moderate',
  },
  {
    slug: "smart-card-authentication",
    name: "Smart Card Authentication",
    description: "Uses a physical smart card with an embedded certificate.",
    useCase: "Government (e.g., PIV/CAC cards), military, finance.",
    security: "High",
    complexity: "High",
    protocols: "PKI",
    phishingResistance: 'High',
    ux: 'High Friction',
    credentialType: 'Private Key (Hardware)',
    standardization: 'ISO/IEC 7816, PKI',
    technicalExplanation: "A form of certificate-based authentication where the certificate and its private key are stored on a secure, tamper-resistant cryptographic chip in a physical card. This provides strong two-factor authentication: something you have (the card) and something you know (a PIN to unlock the card for use). The private key never leaves the card; instead, cryptographic operations like signing are performed on the card itself. This makes it extremely resistant to theft or malware on the host computer.",
    setupInstructions: PlaceholderSetup,
    diagram: GenericAuthDiagram,
    pros: ["Extremely high security", "Tamper-resistant hardware", "Strong MFA"],
    cons: ["Requires physical hardware and readers", "High cost and infrastructure overhead"],
    ssoCapability: 'Possible',
    developerExperience: 'Complex',
  },
  {
    slug: "social-authentication",
    name: "Social Authentication",
    description: "Uses existing login information from social networks.",
    useCase: "Consumer applications, reducing friction for user signup.",
    security: "High",
    complexity: "Medium",
    protocols: "OAuth2, OIDC",
    phishingResistance: 'Medium',
    ux: 'Low Friction',
    credentialType: 'Social Account',
    standardization: 'OAuth2, OIDC',
    technicalExplanation: "This is a user-friendly application of the OAuth 2.0 and OIDC protocols. Instead of creating a new account with a password for your site, users can log in using their existing credentials from a social provider like Google, GitHub, or Facebook. This simplifies registration, offloads password management to the trusted social provider, and can allow your application to request basic profile information (with user consent).",
    setupInstructions: PlaceholderSetup,
    diagram: OAuth2Diagram,
    pros: ["Reduces signup friction", "No need to store user passwords", "Leverages trusted providers"],
    cons: ["Dependency on third-party providers", "Privacy concerns for users"],
    ssoCapability: 'Native',
    developerExperience: 'Moderate',
  },
  {
    slug: "one-time-password",
    name: "One-Time Password (OTP)",
    description: "A password that is valid for only one login session or transaction.",
    useCase: "As a second factor in MFA, verifying transactions.",
    security: "Medium",
    complexity: "Low",
    protocols: "Varies (SMS, App)",
    phishingResistance: 'Medium',
    ux: 'Medium Friction',
    credentialType: 'Single-use Code',
    standardization: 'IETF RFC 4226/6238',
    technicalExplanation: "An OTP is a temporary, dynamic code used for authentication. Common types include HOTP (counter-based) and TOTP (Time-based), which is used by apps like Google Authenticator. During setup, a shared secret is established between the server and the user's app (or device). Both then use this secret and a moving factor (the current time for TOTP, a counter for HOTP) to independently generate the same short-lived code. OTPs sent via SMS are also common but are less secure due to risks of SIM swapping.",
    setupInstructions: PlaceholderSetup,
    diagram: GenericAuthDiagram,
    pros: ["Good second factor for MFA", "Protects against password reuse"],
    cons: ["Can be phished", "SMS-based OTP is vulnerable to SIM-swapping"],
    ssoCapability: 'Not Suited',
    developerExperience: 'Easy',
  },
  {
    slug: "zero-trust-authentication",
    name: "Zero Trust Authentication",
    description: "Assumes no implicit trust and continuously verifies every access attempt.",
    useCase: "Modern cloud-native environments, protecting against lateral movement.",
    security: "High",
    complexity: "High",
    protocols: "Varies",
    phishingResistance: 'High',
    ux: 'Varies',
    credentialType: 'Varies (Contextual)',
    standardization: 'NIST Framework',
    technicalExplanation: "Zero Trust is a security architecture, not a single technology. It's built on the principle of 'never trust, always verify.' It assumes that any access request could be a threat, regardless of its origin (inside or outside the corporate network). Authentication and authorization are not one-time events but are re-evaluated continuously based on a rich set of signals, including user identity, device health and posture, location, and the sensitivity of the requested data. It moves security from the network perimeter to individual resources.",
    setupInstructions: PlaceholderSetup,
    diagram: GenericAuthDiagram,
    pros: ["Strong security posture", "Protects against lateral movement", "Adapts to modern infrastructure"],
    cons: ["Very complex to design and implement", "Can impact user experience if not tuned"],
    ssoCapability: 'Native',
    developerExperience: 'Complex',
  },
  {
    slug: "webauthn",
    name: "WebAuthn",
    description: "A web standard for secure, passwordless authentication using public-key cryptography.",
    useCase: "Modern web applications, passwordless login, phishing-resistant MFA.",
    security: "High",
    complexity: "High",
    protocols: "WebAuthn API",
    phishingResistance: 'High',
    ux: 'Low Friction',
    credentialType: 'Private Key (Device)',
    standardization: 'W3C/FIDO',
    technicalExplanation: "WebAuthn is a W3C standard that enables passwordless and phishing-resistant authentication. It allows websites to use built-in authenticators (like Touch ID, Face ID, Windows Hello) or external security keys (like YubiKeys) for login. It uses public-key cryptography where a private key, securely stored on the user's authenticator, is used to sign a challenge from the server. The server verifies this signature with the corresponding public key. This proves user possession of the authenticator and is scoped per-origin, preventing phishing.",
    setupInstructions: PlaceholderSetup,
    diagram: GenericAuthDiagram,
    pros: ["Highest phishing resistance", "Passwordless and convenient", "Standardized web API"],
    cons: ["Requires browser/device support", "Users need to understand the new flow", "Account recovery can be complex"],
    ssoCapability: 'Possible',
    developerExperience: 'Complex',
  },
  {
    slug: "mutual-tls",
    name: "Mutual TLS (mTLS)",
    description: "Both client and server authenticate each other using TLS certificates.",
    useCase: "Server-to-server APIs (microservices), IoT devices, Zero Trust networks.",
    security: "High",
    complexity: "High",
    protocols: "TLS",
    phishingResistance: 'High',
    ux: 'N/A',
    credentialType: 'Private Key',
    standardization: 'IETF RFC 8446',
    technicalExplanation: "In standard TLS (used in HTTPS), only the client verifies the server's certificate to ensure it's talking to the right server. In mTLS, this verification is bidirectional. The server also requests and validates the client's certificate during the initial TLS handshake. This provides strong, cryptographic proof of identity for both parties in a connection before any application data (like HTTP requests) is exchanged. It is ideal for non-interactive systems like microservices or IoT devices.",
    setupInstructions: PlaceholderSetup,
    diagram: GenericAuthDiagram,
    pros: ["Strong, cryptographic identity for services", "Authenticates at the transport layer"],
    cons: ["Certificate management at scale is complex", "Not suited for user-facing applications"],
    ssoCapability: 'Not Suited',
    developerExperience: 'Complex',
  },
  {
    slug: "delegated-authentication",
    name: "Delegated Authentication",
    description: "Delegates the authentication process to a trusted external service or identity provider.",
    useCase: "Integrating with enterprise IdPs, using third-party login services.",
    security: "High",
    complexity: "High",
    protocols: "SAML, OAuth2, OIDC",
    phishingResistance: 'Medium',
    ux: 'Low Friction',
    credentialType: 'Varies (Token/Assertion)',
    standardization: 'SAML, OAuth2, OIDC',
    technicalExplanation: "This is a broad architectural pattern that underpins SSO, social logins, and enterprise federation. An application (the Service Provider) chooses not to manage user credentials itself. Instead, it delegates the entire authentication process to a dedicated, trusted Identity Provider (IdP). The application establishes a trust relationship with the IdP (via a protocol like SAML or OIDC) and consumes security tokens (like SAML assertions or OIDC ID tokens) to log users in. This centralizes identity management and improves security.",
    setupInstructions: PlaceholderSetup,
    diagram: OAuth2Diagram,
    pros: ["Reduces security burden on application", "Enables SSO and federation", "Leverages specialized identity services"],
    cons: ["Creates dependency on IdP", "Requires understanding of federation protocols"],
    ssoCapability: 'Native',
    developerExperience: 'Complex',
  },
];
